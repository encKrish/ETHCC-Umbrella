"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const jsonschema_1 = require("jsonschema");
const js_yaml_1 = require("js-yaml");
const axios_1 = __importDefault(require("axios"));
const feeds_schema_1 = __importDefault(require("../config/feeds-schema"));
const urlCache = createUrlCache();
async function loadFeeds(filePath) {
    try {
        new URL(filePath);
        return await processYaml(await urlCache.loadFromURL(filePath, true));
    }
    catch (err) {
        return await processYaml(await loadFromFile(filePath));
    }
}
exports.default = loadFeeds;
async function processYaml(feedData, ignoreInvalid = true) {
    const [feeds] = js_yaml_1.loadAll(feedData);
    const result = new jsonschema_1.Validator().validate(feeds, feeds_schema_1.default);
    if (!result.valid) {
        if (!ignoreInvalid) {
            throw new Error(`Feeds validation error:\n${result.errors.map((err) => err.toString()).join('; ')}`);
        }
        result.errors.forEach((error) => {
            delete feeds[error.path[0]];
        });
        const updatedResult = new jsonschema_1.Validator().validate(feeds, feeds_schema_1.default);
        if (!updatedResult.valid) {
            throw new Error(`Feeds validation error (pass 2):\n${result.errors.map((err) => err.toString()).join('; ')}`);
        }
    }
    return feeds;
}
async function loadFromFile(filePath) {
    return new Promise((resolve, reject) => {
        fs_1.default.readFile(filePath, 'utf-8', async (err, feedData) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(feedData);
            }
        });
    });
}
function createUrlCache() {
    const etagCache = {};
    const dataCache = {};
    return {
        loadFromURL: async (url, ignoreErrors = true) => {
            const etag = etagCache[url];
            const prevData = dataCache[etag];
            try {
                const response = await axios_1.default.get(url, {
                    headers: { ...(etag ? { 'If-None-Match': etag } : {}) },
                    validateStatus: function (status) {
                        return status < 400;
                    },
                });
                if (response.status === 304) {
                    return prevData;
                }
                else if (response.status !== 200) {
                    throw new Error(response.data);
                }
                if (response.data.Response === 'Error') {
                    throw new Error(response.data.Message);
                }
                const { etag: nextEtag } = response.headers;
                etagCache[url] = nextEtag;
                dataCache[nextEtag] = response.data;
                return response.data;
            }
            catch (err) {
                if (ignoreErrors) {
                    return prevData;
                }
                throw err;
            }
        },
    };
}
//# sourceMappingURL=loadFeeds.js.map