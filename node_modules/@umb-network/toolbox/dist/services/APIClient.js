"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.APIClient = void 0;
const axios_1 = __importDefault(require("axios"));
const LeafValueCoder_1 = require("./LeafValueCoder");
const ethers_1 = require("ethers");
class APIClient {
    constructor(options) {
        this.options = options;
        this.axios = axios_1.default.create({
            baseURL: options.baseURL,
        });
    }
    async getBlocks(options) {
        const response = await this.axios.get('/blocks', {
            headers: {
                authorization: `Bearer ${this.options.apiKey}`,
            },
            params: options,
        });
        return APIClient.transformBlocksFromApi(response.data);
    }
    async getBlock(blockId) {
        const response = await this.axios.get(`/blocks/${blockId}`, {
            headers: {
                authorization: `Bearer ${this.options.apiKey}`,
            },
        });
        return APIClient.transformBlockFromApi(response.data.data);
    }
    async getNewestBlock() {
        return (await this.getBlocks({ limit: 1 }))[0];
    }
    async getLeavesOfBlock(blockId) {
        const response = await this.axios.get(`/blocks/${blockId}/leaves`, {
            headers: {
                authorization: `Bearer ${this.options.apiKey}`,
            },
        });
        return response.data;
    }
    async getProofs(keys) {
        const response = await this.axios.get('/proofs', {
            headers: {
                authorization: `Bearer ${this.options.apiKey}`,
            },
            params: { keys },
        });
        if (response.data.data.block) {
            return {
                block: APIClient.transformBlockFromApi(response.data.data.block),
                keys: response.data.data.keys,
                leaves: response.data.data.leaves,
            };
        }
        return null;
    }
    /**
     * Uses verifyProofForBlock method of the Chain contract.
     * @see https://kovan.etherscan.io/address/[contract-address]#readContract
     */
    async verifyProofForNewestBlock(key) {
        if (!this.options.chainContract) {
            throw new Error('chainContract is required');
        }
        const proofs = await this.getProofs([key]);
        if (!proofs || proofs.leaves.length === 0 || !proofs.leaves[0].proof) {
            throw new Error('Proof not found');
        }
        const success = await this.options.chainContract.verifyProofForBlock(proofs.block.blockId, proofs.leaves[0].proof, key, proofs.leaves[0].value);
        return {
            success,
            value: LeafValueCoder_1.LeafValueCoder.decode(proofs.leaves[0].value, key),
            dataTimestamp: proofs.block.dataTimestamp,
        };
    }
    static transformBlockFromApi(apiBlockData) {
        return {
            ...apiBlockData,
            anchor: ethers_1.BigNumber.from(apiBlockData.anchor),
            power: ethers_1.BigNumber.from(apiBlockData.power),
            staked: ethers_1.BigNumber.from(apiBlockData.staked),
            dataTimestamp: new Date(apiBlockData.dataTimestamp),
        };
    }
    static transformBlocksFromApi(apiBlocksData) {
        return apiBlocksData.map(APIClient.transformBlockFromApi);
    }
}
exports.APIClient = APIClient;
//# sourceMappingURL=APIClient.js.map