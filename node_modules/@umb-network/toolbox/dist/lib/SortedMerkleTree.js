"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SortedMerkleTree = void 0;
const ethers_1 = require("ethers");
const LeafKeyCoder_1 = require("../services/LeafKeyCoder");
const helpers_1 = require("../utils/helpers");
const hash = ethers_1.ethers.utils.solidityKeccak256;
const lastHash = '0x' + 'f'.repeat(64);
const emptyRoot = ethers_1.ethers.constants.HashZero;
const isOdd = (n) => n % 2 !== 0;
class SortedMerkleTree {
    constructor(keyValuePairs) {
        this.keys = {};
        this.tree = [];
        this.data = keyValuePairs;
        if (Object.keys(this.data).length > 0) {
            this.createTree(this.addEvenHash(this.createLeaves(this.data)));
        }
    }
    hashIt(h1, h2) {
        const sorted = [h1, h2].sort();
        return hash(['bytes32', 'bytes32'], [sorted[0], sorted[1]]);
    }
    leafHash(k, v) {
        return hash(['bytes32', 'bytes32'], [k, v]);
    }
    createLeafHash(k) {
        return this.leafHash(LeafKeyCoder_1.LeafKeyCoder.encode(k), this.data[k]);
    }
    addEvenHash(hashes) {
        if (hashes.length > 1 && isOdd(hashes.length)) {
            hashes.push(lastHash);
        }
        return hashes;
    }
    createLeaves(keyValuePairs) {
        return Object.keys(keyValuePairs)
            .sort()
            .map((k, i) => {
            this.keys[k] = i;
            return this.createLeafHash(k);
        });
    }
    createNextTreeLevel(inputs) {
        const hashes = [];
        for (let i = 0; i + 1 < inputs.length; i += 2) {
            hashes.push(this.hashIt(inputs[i], inputs[i + 1]));
        }
        return hashes;
    }
    createTree(inputs) {
        this.tree.push(inputs);
        if (inputs.length > 1) {
            const nextLevelInputs = this.createNextTreeLevel(inputs);
            this.createTree(this.addEvenHash(nextLevelInputs));
        }
    }
    getLeaves() {
        return this.tree.length > 0 ? this.tree[0] : [];
    }
    getIndexForKey(key) {
        return this.keys[key];
    }
    generateProof(level, idx, proof = []) {
        if (level === this.tree.length - 1) {
            return proof;
        }
        const treeLevel = this.tree[level];
        const siblingIdx = idx + (isOdd(idx) ? -1 : +1);
        proof.push(treeLevel[siblingIdx]);
        return this.generateProof(level + 1, Math.floor(idx / 2), proof);
    }
    getProofForKey(key) {
        return this.generateProof(0, this.getIndexForKey(key));
    }
    getRoot() {
        if (this.tree.length === 0) {
            return emptyRoot;
        }
        return this.tree[this.tree.length - 1][0];
    }
    verifyProof(proof, root, leaf) {
        let computedHash = leaf;
        proof.forEach((proofElement) => {
            if (computedHash <= proofElement) {
                computedHash = this.hashIt(computedHash, proofElement);
            }
            else {
                computedHash = this.hashIt(proofElement, computedHash);
            }
        });
        return computedHash === root;
    }
    static flattenProofs(proofs) {
        const proofItemsCounter = [];
        const flattened = '0x' +
            proofs
                .map((proof) => {
                proofItemsCounter.push(proof.length);
                return proof.map((item) => helpers_1.remove0x(item)).join('');
            })
                .join('');
        return { proofs: flattened, proofItemsCounter };
    }
}
exports.SortedMerkleTree = SortedMerkleTree;
//# sourceMappingURL=SortedMerkleTree.js.map